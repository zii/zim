package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"math/rand"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"zim.cn/biz/rpcx"

	"zim.cn/service/apisvc/rpcmethod"

	"zim.cn/biz/proto"

	"github.com/Shopify/sarama"

	"zim.cn/biz/kafka"

	"zim.cn/biz"

	"zim.cn/biz/config"

	"zim.cn/base/uuid"

	"zim.cn/base"
	"zim.cn/service"
	"zim.cn/service/apisvc/method"

	"github.com/gorilla/mux"
	rpcxserver "github.com/smallnest/rpcx/server"
	httpSwagger "github.com/swaggo/http-swagger"
	"zim.cn/base/log"
	_ "zim.cn/service/docs" // docs is generated by Swag CLI, you have to import it.
)

const (
	VERSION = "0.1.0"
)

var args struct {
	Port     int
	ConfFile string
	CertFile string
	KeyFile  string
}

func healthHandler(_ http.ResponseWriter, _ *http.Request) {
}

func init() {
	if base.RELEASE {
		log.SetLevel(log.LvInfo)
	}

	flag.StringVar(&args.ConfFile, "config", "config.toml", "config file")
	flag.IntVar(&args.Port, "port", 1840, "server listening port")
	flag.StringVar(&args.CertFile, "cert", "cert.pem", "tls cert file")
	flag.StringVar(&args.KeyFile, "key", "key.pem", "tls private key file")
	rand.Seed(time.Now().Unix())
}

func main() {
	flag.Parse()

	log.Println("version:", VERSION)
	log.Println("RELEASE:", base.RELEASE)
	log.Println("config:", args.ConfFile)

	service.InitSwag()

	err := uuid.InitUUID()
	base.Raise(err)

	conf := config.LoadConfigFile(args.ConfFile)
	conf.Init()
	biz.InitUserId()

	router := mux.NewRouter()
	// 健康检查
	router.HandleFunc("/health", healthHandler)
	router.HandleFunc("/v1/health", healthHandler)

	// swagger文档入口
	router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	service.RegisterMethod(router, "/v1/test/test", method.Test_test, false)

	service.RegisterMethod(router, "/v1/sys/register", method.Sys_register, false)
	service.RegisterMethod(router, "/v1/sys/authToken", method.Sys_authToken, false)
	service.RegisterMethod(router, "/v1/sys/disconnect", method.Sys_disconnect, false)
	service.RegisterMethod(router, "/v1/sys/sendMessage", method.Sys_sendMessage, false)
	service.RegisterMethod(router, "/v1/sys/logout", method.Sys_logout, false)
	service.RegisterMethod(router, "/v1/sys/editUser", method.Sys_editUser, false)
	service.RegisterMethod(router, "/v1/sys/ban", method.Sys_ban, false)
	service.RegisterMethod(router, "/v1/sys/unban", method.Sys_unban, false)

	service.RegisterMethod(router, "/v1/message/getDialogs", method.Message_getDialogs, true)
	service.RegisterMethod(router, "/v1/message/sendMessage", method.Message_sendMessage, true)
	service.RegisterMethod(router, "/v1/message/readHistory", method.Message_readHistory, true)
	service.RegisterMethod(router, "/v1/message/pullHistory", method.Message_pullHistory, true)
	service.RegisterMethod(router, "/v1/message/deleteMessages", method.Message_deleteMessages, true)
	service.RegisterMethod(router, "/v1/message/pullEvents", method.Message_pullEvents, true)
	service.RegisterMethod(router, "/v1/message/forwardMessages", method.Message_forwardMessages, true)
	service.RegisterMethod(router, "/v1/message/clearDialog", method.Message_clearDialog, true)
	service.RegisterMethod(router, "/v1/message/deleteDialog", method.Message_deleteDialog, true)
	service.RegisterMethod(router, "/v1/message/pinDialog", method.Message_pinDialog, true)

	service.RegisterMethod(router, "/v1/upload/getCredential", method.Upload_getCredential, true)

	service.RegisterMethod(router, "/v1/user/getUser", method.User_getUser, true)
	service.RegisterMethod(router, "/v1/user/getUsers", method.User_getUsers, true)

	service.RegisterMethod(router, "/v1/account/getChats", method.Account_getChats, true)
	service.RegisterMethod(router, "/v1/account/updateNotifySetting", method.Account_updateNotifySetting, true)

	service.RegisterMethod(router, "/v1/friend/invite", method.Friend_invite, true)
	service.RegisterMethod(router, "/v1/friend/accept", method.Friend_accept, true)
	service.RegisterMethod(router, "/v1/friend/editApply", method.Friend_editApply, true)
	service.RegisterMethod(router, "/v1/friend/deleteApply", method.Friend_deleteApply, true)
	service.RegisterMethod(router, "/v1/friend/getApplyList", method.Friend_getApplyList, true)
	service.RegisterMethod(router, "/v1/friend/getFriends", method.Friend_getFriends, true)
	service.RegisterMethod(router, "/v1/friend/edit", method.Friend_edit, true)
	service.RegisterMethod(router, "/v1/friend/remove", method.Friend_remove, true)
	service.RegisterMethod(router, "/v1/friend/add", method.Friend_add, true)
	service.RegisterMethod(router, "/v1/friend/block", method.Friend_block, true)
	service.RegisterMethod(router, "/v1/friend/unblock", method.Friend_unblock, true)
	service.RegisterMethod(router, "/v1/friend/getBlocked", method.Friend_getBlocked, true)

	service.RegisterMethod(router, "/v1/chat/create", method.Chat_create, true)
	service.RegisterMethod(router, "/v1/chat/addUser", method.Chat_addUser, true)
	service.RegisterMethod(router, "/v1/chat/deleteUser", method.Chat_deleteUser, true)
	service.RegisterMethod(router, "/v1/chat/mute", method.Chat_mute, true)
	service.RegisterMethod(router, "/v1/chat/unmute", method.Chat_unmute, true)
	service.RegisterMethod(router, "/v1/chat/muteUser", method.Chat_muteUser, true)
	service.RegisterMethod(router, "/v1/chat/unmuteUser", method.Chat_unmuteUser, true)
	service.RegisterMethod(router, "/v1/chat/editName", method.Chat_editName, true)
	service.RegisterMethod(router, "/v1/chat/editRole", method.Chat_editRole, true)
	service.RegisterMethod(router, "/v1/chat/editInfo", method.Chat_editInfo, true)
	service.RegisterMethod(router, "/v1/chat/transferOwner", method.Chat_transferOwner, true)
	service.RegisterMethod(router, "/v1/chat/dismiss", method.Chat_dismiss, true)
	service.RegisterMethod(router, "/v1/chat/getChat", method.Chat_getChat, true)
	service.RegisterMethod(router, "/v1/chat/getMembers", method.Chat_getMembers, true)

	// rpcx api
	var xserver *rpcxserver.Server
	{
		log.Println("rpcx listening:", conf.Rpcx.Port)
		s := rpcxserver.NewServer()
		xserver = s

		s.RegisterFunctionName(rpcx.ServicePath, "register", rpcmethod.Sys_register, "")
		s.RegisterFunctionName(rpcx.ServicePath, "authToken", rpcmethod.Sys_authToken, "")
		s.RegisterFunctionName(rpcx.ServicePath, "sendMessage", rpcmethod.Sys_sendMessage, "")
		s.RegisterFunctionName(rpcx.ServicePath, "disconnect", rpcmethod.Sys_disconnect, "")
		s.RegisterFunctionName(rpcx.ServicePath, "logout", rpcmethod.Sys_logout, "")
		s.RegisterFunctionName(rpcx.ServicePath, "editUser", rpcmethod.Sys_editUser, "")
		s.RegisterFunctionName(rpcx.ServicePath, "ban", rpcmethod.Sys_ban, "")
		s.RegisterFunctionName(rpcx.ServicePath, "unban", rpcmethod.Sys_unban, "")

		go s.Serve("tcp", fmt.Sprintf("0.0.0.0:%d", conf.Rpcx.Port))
	}
	_ = xserver

	// Interrupt handler.
	errc := make(chan error)
	go func() {
		c := make(chan os.Signal)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		errc <- fmt.Errorf("%s", <-c)
	}()

	// History message consume queue.
	rd_flusher := biz.NewFlusher(500, 1*time.Second, biz.BulkFlushRedis)
	db_flusher := biz.NewFlusher(2000, 1*time.Second, biz.BulkFlushDB)
	if conf.Kafka.Enable {
		// redis consumer
		c := kafka.NewConsumer(conf.Kafka.Brokers, conf.Kafka.Level1Topic, conf.Kafka.Level1Group)
		go func() {
			c.Run(func(m *sarama.ConsumerMessage) bool {
				//log.Println("<-", m.Topic, m.Partition, m.Offset, string(m.Value))
				var cmd *proto.Command
				err := json.Unmarshal(m.Value, &cmd)
				if err != nil {
					log.Println("unmarshal err:", err)
					return true
				}
				rd_flusher.Push(cmd)
				return true
			})
		}()
		// db consumer, 搞成批量插入
		c = kafka.NewConsumer(conf.Kafka.Brokers, conf.Kafka.Level2Topic, conf.Kafka.Level2Group)
		go func() {
			c.Run(func(m *sarama.ConsumerMessage) bool {
				//log.Println("<-", m.Topic, m.Partition, m.Offset, string(m.Value))
				var cmd *proto.Command
				err := json.Unmarshal(m.Value, &cmd)
				if err != nil {
					log.Println("unmarshal err:", err)
					return true
				}
				// 最大积累到5000条批量插入mysql, 最大等待1秒
				db_flusher.Push(cmd)
				return true
			})
		}()
		go db_flusher.Run()
		go rd_flusher.Run()
	}

	// HTTP transport.
	go func() {
		listenAddr := fmt.Sprintf("0.0.0.0:%d", args.Port)
		log.Println("listening:", listenAddr)
		server := &http.Server{
			Addr:        listenAddr,
			Handler:     router,
			IdleTimeout: 300 * time.Second,
		}
		err := server.ListenAndServe()
		//err := http.ListenAndServe(listenAddr, router)
		base.Raise(err)
	}()

	// Run!
	log.Println("exit:", <-errc)
	//xserver.Close()
	rd_flusher.Flush()
	db_flusher.Flush()
}
