消息的内部机制

1、IM单群聊的离线、在线消息存储机制
每条消息, 无论用户是否在线都保存到数据库. 发送消息先加入kafka队列, 再由消费者服务有序地取出并写入数据库.
kafka的特性是直接写磁盘日志文件, 可以保证可靠性, 只要没有被消费成功, 消息就不会丢失.

2、IM单群聊的在线、离线状态存储机制
用户在线状态保存在redis, 每个用户对应多个设备token, 用map保存. 如果map长度由0变为1,发送上线消息, 变为0, 发送离线消息;
原则上用户上线之后要给所有对话列表(用户/群), 以及通讯录成员, 广播上线事件.
考虑到消息量太大, 可以做让对方成定期拉取.

3、IM单群聊的读写机制
单聊消息采用写扩散, 发送方和接收方各存一份消息副本, 用户单方面删除对话消息不会影响到对方;
普通群消息采用写扩散, 消息在用户信箱表存n个副本, n是成员人数, 用户单方面删除对话消息不会影响到别的成员;
超级群采用读扩散, 每个超级群有独立的信箱和独立的消息ID, 每条消息只存一份, 用户删除消息所有人都会删除;

4、IM单群聊的消息收发（推拉）机制
发单聊消息: 客户端A首先调用发送消息接口, API服务器再将消息发送给网关服务器, 由网关服务器发送给目标用户客户端.
发群消息: 客户端A首先调用发送消息接口, API服务器再将消息发送给网关服务器, 由网关服务器广播给群成员客户端.
拉取离线消息: 客户端根据上次已读消息ID, 调用API拉取离线期间的聊天记录.

5、IM单群聊已读未读状态机制
分两个角度:
5.1 标记已读: 用户自己已经读了哪些别人的消息, 还有哪些未读. 这里服务端会记录用户每个对话的已读ID和未读数, 离线期间每收到一个消息, 未读数都会加1.
	发送者自己默认为已经读完所有对话消息, 未读数清0.
5.2 已读回执: 我发的消息是否已经被别人看过. 这里服务端会记录每个对话的最新已读回执ID, 小于等于max_id的消息应显示为已读.

6、IM未读消息数记录存储策略
单聊和普通群: 每个对话服务端都会都维护一个未读数计数器;
超级群: 通过一个技巧, 未读数=最新ID减去上次已读ID;

7、IM多端登录策略
每个设备通过认证接口申请到一个唯一的token, 每个token除了验证身份, 也代表一个设备.
用户再次申请新token的时候, 服务端会根据具体策略和已有的token和设备类型, 返回认证结果.

8、IM多向删除策略
删除自己和对方的聊天记录即可.

9、IM微服务模块设计
消息服务, 网关服务, 通知服务, 好友服务, 音视频服务...

10、IM端到端加密的私密会话策略
客户端之间通过DH算法协商密钥, 服务端只起到转发的作用, 由于DH的特性交换密钥的过程服务端无法破解.
私密对话和常规对话是分开的, 只有双方都在线的情况下才能建立私密对话.

11、IM多节点分布机制

12、IM熔断限流机制
服务器负载过高的时候, 关闭一些不重要的功能, 仅提供核心的消息服务.
